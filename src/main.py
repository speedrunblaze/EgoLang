import py_compile
import os
import re
from typing import Dict, Any


class EgoError(Exception):
    pass


class Variable:
    def __init__(self, value, type_name, visibility="public", mutability="mutable"):
        self.value = value
        self.type = type_name
        self.visibility = visibility
        self.mutability = mutability
    
    def can_modify(self):
        return self.mutability == "mutable"


class Scope:
    def __init__(self, parent=None):
        self.vars = {}
        self.parent = parent
        
    def get(self, name):
        if name in self.vars:
            return self.vars[name]
        elif self.parent:
            return self.parent.get(name)
        return None
        
    def declare(self, name, value, type_name, visibility, mutability):
        if name in self.vars and not self.vars[name].can_modify():
            raise EgoError(f"Cannot redeclare immutable variable '{name}'")
                
        var = Variable(value, type_name, visibility, mutability)
        self.vars[name] = var
        return var
        
    def update(self, name, value):
        if name in self.vars:
            var = self.vars[name]
            if not var.can_modify():
                raise EgoError(f"Cannot modify immutable variable '{name}'")
            
            var.value = value
            return var
        
        elif self.parent:
            return self.parent.update(name, value)
            
        raise EgoError(f"Variable '{name}' is not defined")


class EgoJITCompiler:
    TYPES = ["int", "float", "string", "bool", "list", "dict"]
    VISIBILITIES = ["public", "private", "protected"]
    MUTABILITIES = ["mutable", "immutable", "const"]
    
    def __init__(self):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        
    def parse(self, code):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        
        python_code = [
            "# Generated by EgoJITCompiler",
            "import sys"
        ]
        
        clean_code = self._clean(code)
        blocks = self._split_blocks(clean_code)
        
        for block in blocks:
            try:
                result = self._translate(block)
                if result:
                    python_code.append(result)
            except EgoError as e:
                python_code.append(f"# Error: {str(e)}")
        
        return "\n".join(python_code)
        
    def _clean(self, code):
        code = re.sub(r'//.*$', '', code, flags=re.MULTILINE)
        code = re.sub(r'/\*[\s\S]*?\*/', '', code)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        lines = []
        for line in code.split('\n'):
            content = line.strip()
            if content:
                lines.append(content)
        
        return '\n'.join(lines)

    def _split_blocks(self, code):
        blocks = []
        current = ""
        
        brace_count = 0
        in_string = False
        string_char = None
        escape = False
        
        for char in code:
            current += char
            
            if char in ['"', "'"] and not escape:
                if not in_string:
                    in_string = True
                    string_char = char
                elif string_char == char:
                    in_string = False
                    
            if char == '\\' and in_string and not escape:
                escape = True
            else:
                escape = False
                
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    
                if char == ';' and brace_count == 0:
                    blocks.append(current.strip())
                    current = ""
        
        if current.strip():
            blocks.append(current.strip())
            
        return blocks
        
    def _translate(self, block):
        block = block.strip()
        
        if block.endswith(';'):
            block = block[:-1].strip()
            
        if not block:
            return ""
            
        if self._is_var_decl(block):
            return self._translate_var(block)
        elif self._is_func_decl(block):
            return self._translate_func(block)
        elif self._is_if(block):
            return self._translate_if(block)
        elif self._is_loop(block):
            return self._translate_loop(block)
        elif self._is_print(block):
            return self._translate_print(block)
        elif self._is_assign(block):
            return self._translate_assign(block)
        else:
            return f"# Unrecognized: {block}"
            
    def _is_var_decl(self, block):
        pattern = r'^(public|private|protected)\s+(mutable|immutable|const)\s+\w+\s+\w+\s*=.*$'
        return bool(re.match(pattern, block))
            
    def _translate_var(self, block):
        parts = block.split('=', 1)
        declaration = parts[0].strip().split()
        value = parts[1].strip()
        
        visibility = declaration[0]
        mutability = declaration[1]
        type_name = declaration[2]
        var_name = declaration[3]
        
        if visibility not in self.VISIBILITIES:
            raise EgoError(f"Invalid visibility: {visibility}")
            
        if mutability not in self.MUTABILITIES:
            raise EgoError(f"Invalid mutability: {mutability}")
            
        if type_name not in self.TYPES:
            raise EgoError(f"Invalid type: {type_name}")
            
        self.current_scope.declare(var_name, value, type_name, visibility, mutability)
        
        py_value = self._convert_value(value, type_name)
        return f"{var_name} = {py_value}"
        
    def _convert_value(self, value, type_name):
        if type_name == "string" and not (value.startswith('"') or value.startswith("'")):
            return f'"{value}"'
        elif type_name == "bool":
            if value.lower() == "true":
                return "True"
            elif value.lower() == "false":
                return "False"
        return value
        
    def _is_func_decl(self, block):
        pattern = r'^(public|private|protected)\s+function\s+\w+\s*\(.*\)\s*\{.*\}$'
        return bool(re.match(pattern, block, re.DOTALL))
        
    def _translate_func(self, block):
        match = re.match(r'^(public|private|protected)\s+function\s+(\w+)\s*\((.*)\)\s*\{(.*)\}$', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid function syntax")
            
        visibility, name, params_str, body = match.groups()
        
        params = []
        for param in params_str.split(','):
            param = param.strip()
            if param:
                param_parts = param.split()
                if len(param_parts) >= 2:
                    param_name = param_parts[-1]
                    params.append(param_name)
        
        # Create new scope for function
        old_scope = self.current_scope
        self.current_scope = Scope(old_scope)
        
        # Process function body
        body_lines = []
        for line in body.split(';'):
            line = line.strip()
            if line:
                translated = self._translate(line)
                if translated:
                    body_lines.append(f"    {translated}")
        
        # Restore scope
        self.current_scope = old_scope
        
        return f"def {name}({', '.join(params)}):\n" + "\n".join(body_lines)
        
    def _is_if(self, block):
        return block.startswith('if')
        
    def _translate_if(self, block):
        # Basic if statement handling
        match = re.match(r'if\s*\((.*)\)\s*\{(.*)\}(?:\s*else\s*\{(.*)\})?', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid if statement syntax")
            
        condition, if_body, else_body = match.groups()
        
        # Translate condition
        condition = condition.replace('==', '==').replace('!=', '!=')
        
        # Translate bodies
        if_lines = []
        for line in if_body.split(';'):
            line = line.strip()
            if line:
                translated = self._translate(line)
                if translated:
                    if_lines.append(f"    {translated}")
        
        result = [f"if {condition}:"]
        result.extend(if_lines)
        
        if else_body:
            else_lines = []
            for line in else_body.split(';'):
                line = line.strip()
                if line:
                    translated = self._translate(line)
                    if translated:
                        else_lines.append(f"    {translated}")
            
            result.append("else:")
            result.extend(else_lines)
        
        return "\n".join(result)
        
    def _is_loop(self, block):
        return block.startswith('for') or block.startswith('while')
        
    def _translate_loop(self, block):
        if block.startswith('for'):
            match = re.match(r'for\s*\((.*);(.*);(.*)\)\s*\{(.*)\}', block, re.DOTALL)
            if not match:
                raise EgoError("Invalid for loop syntax")
                
            init, cond, update, body = match.groups()
            
            # Translate parts
            init_code = self._translate(init)
            cond_code = cond.strip()
            update_code = self._translate(update)
            
            # Handle body
            body_lines = []
            for line in body.split(';'):
                line = line.strip()
                if line:
                    translated = self._translate(line)
                    if translated:
                        body_lines.append(f"    {translated}")
            
            # Add update at end of loop body
            if update_code:
                body_lines.append(f"    {update_code}")
            
            result = []
            if init_code:
                result.append(init_code)
            result.append(f"while {cond_code}:")
            result.extend(body_lines)
            
            return "\n".join(result)
        else:  # while loop
            match = re.match(r'while\s*\((.*)\)\s*\{(.*)\}', block, re.DOTALL)
            if not match:
                raise EgoError("Invalid while loop syntax")
                
            condition, body = match.groups()
            
            # Handle body
            body_lines = []
            for line in body.split(';'):
                line = line.strip()
                if line:
                    translated = self._translate(line)
                    if translated:
                        body_lines.append(f"    {translated}")
            
            result = [f"while {condition}:"]
            result.extend(body_lines)
            
            return "\n".join(result)
        
    def _is_print(self, block):
        return block.startswith('print')
        
    def _translate_print(self, block):
        match = re.match(r'print\s*\((.*)\)', block)
        if not match:
            raise EgoError("Invalid print statement")
            
        arg = match.group(1).strip()
        var = self.current_scope.get(arg)
        
        if not var and not (arg.startswith('"') or arg.startswith("'")):
            raise EgoError(f"Variable '{arg}' not defined")
            
        return f"print({arg})"
        
    def _is_assign(self, block):
        return '=' in block and not self._is_var_decl(block)
        
    def _translate_assign(self, block):
        parts = block.split('=', 1)
        var_name = parts[0].strip()
        value = parts[1].strip()
        
        var = self.current_scope.get(var_name)
        if not var:
            raise EgoError(f"Variable '{var_name}' not defined")
            
        if not var.can_modify():
            raise EgoError(f"Cannot modify immutable variable '{var_name}'")
            
        self.current_scope.update(var_name, value)
        
        return f"{var_name} = {value}"
    
    def compile(self, ego_code, output_file):
        python_code = self.parse(ego_code)
        temp_file = 'temp_ego_code.py'
        
        with open(temp_file, 'w') as f:
            f.write(python_code)
        
        try:
            py_compile.compile(temp_file, cfile=output_file)
            os.remove(temp_file)
            print(f"Compiled successfully to '{output_file}'")
        except py_compile.PyCompileError as e:
            print(f"Compilation failed: {e}")
            os.remove(temp_file)


# Example usage
compiler = EgoJITCompiler()
sample_code = """

// Demonstrate all variable types with different visibilities and mutabilities

// Integer examples
public mutable int counter = 0;
private immutable int maxRetries = 5;
protected const int userId = 12345;

// Float examples
public mutable float price = 19.99;
private immutable float pi = 3.14159;
protected const float taxRate = 0.08;

// String examples
public mutable string message = "Hello, Ego!";
private immutable string appName = "EgoApp";
protected const string version = "1.0.0";

// Boolean examples
public mutable bool isActive = true;
private immutable bool isRequired = false;
protected const bool isProduction = true;

// List example
public mutable list numbers = [1, 2, 3, 4, 5];

// Dictionary example
public mutable dict userInfo = {"name": "John", "age": 30};

// Printing variables
print(counter);
print(price);
print(message);
print(isActive);
print(numbers);
print(userInfo);

// Modifying mutable variables
counter = counter + 1;
price = price * 1.1;
message = message + " Welcome!";
isActive = false;
numbers = [10, 20, 30];
userInfo = {"name": "Jane", "age": 25};

// Print modified values
print(counter);
print(price);
print(message);
print(isActive);
print(numbers);
print(userInfo);

"""
compiler.compile(sample_code, 'function.ego')